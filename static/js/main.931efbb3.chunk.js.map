{"version":3,"sources":["audio/another-world-intro.mp3","audio/r-type-title.mp3","audio/shadow-of-the-beast-intro.mp3","game-config.js","game-functions.js","ai.js","ai-functions.js","index.js"],"names":["module","exports","__webpack_require__","p","characteristicLength","playerOneChar","playerTwoChar","initialDifficulty","difficultyOptions","startMessage","Array","from","getPlayer","playerOneNext","generateWinningLines","length","rows","fill","map","v","i","columns","diagonals","concat","repeat","n","f","randIndex","Math","floor","random","selectRandomEmptySquare","squares","emptySquareIndices","filter","getEmptySquareIndices","selectBestSquareToWin","opponentCharacter","sqrt","initialSquareWeights","squareIndex","weight","getInitialSquareWeights","winningLines","remainingWinningLines","oponentCharacter","line","index","some","playedCaracter","filterByAvailability","bestMoves","squareWeights","sort","a","b","highestWeight","square","getBestMoves","lineWeights","reduce","flatArray","accumulatingSquareWeights","lineWeightsToSquareWeights","numEmptySquares","totalLineWeight","winningLineToWeights","wopr","difficulty","myCharacter","getBestAttack","myBestSquare","opponentBestSquare","getBestSquare","Square","props","classNames","shouldHighlight","isOnWinningLine","react_default","createElement","className","onClick","onMouseOver","onMouseOut","role","aria-label","playerCharacter","Board","_this","this","winningLine","includes","highlight","key","_this2","rowCounter","renderSquare","React","Component","Game","_this3","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","music","anworldAudio","rtypeAudio","shadowAudio","currentMusicIndex","currentMusic","numSquares","state","history","indexPlayed","move","stepNumber","isDraw","winner","gameLock","slice","currentPlayer","_indexToCoords","trunc","_indexToCoords2","slicedToArray","xCoord","yCoord","winningState","result","indices","value","every","winningLineIndices","lines","calculateWinner","setState","reverseHistory","_this4","haveAGo","forceUpdate","computerCharacter","humanCharacter","computerSquareChoice","delay","setTimeout","step","e","newDifficulty","target","status","_this5","current","moveListItems","moveNumber","gameStart","Fragment","desc","isCurrent","currentClass","highlightClass","jumpTo","handleMouseOver","handleMouseOut","difficultyOptionEls","option","initialStartMessage","letter","shift","currentMessage","href","src_Board","handleBoardClick","reverse","controls","src","preload","autoPlay","onEnded","handleEnded","onChange","handleDifficultyChange","packageJson","version","ReactDOM","render","src_Game","document","getElementById"],"mappings":"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","file":"static/js/main.931efbb3.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/another-world-intro.906002dc.mp3\";","module.exports = __webpack_public_path__ + \"static/media/r-type-title.34638760.mp3\";","module.exports = __webpack_public_path__ + \"static/media/shadow-of-the-beast-intro.957ac6e3.mp3\";","// Board width, height, winning length.\r\nconst characteristicLength = 3;\r\n\r\nconst playerOneChar = 'ðŸš€';\r\nconst playerTwoChar = 'ðŸ›°ï¸';\r\n\r\n// easy, medium or hard.\r\nconst initialDifficulty = 'hard';\r\nconst difficultyOptions = ['human', 'easy', 'medium', 'hard'];\r\n\r\nconst startMessage = Array.from(\"SHALL WE PLAY A GAME?\");\r\n\r\nexport {\r\n  characteristicLength,\r\n  playerOneChar,\r\n  playerTwoChar,\r\n  initialDifficulty,\r\n  difficultyOptions,\r\n  startMessage\r\n};\r\n","import {playerOneChar, playerTwoChar} from './game-config.js';\r\n\r\nfunction getPlayer(playerOneNext) {\r\n  return playerOneNext ? playerOneChar : playerTwoChar;\r\n}\r\n\r\nfunction generateWinningLines(length) {\r\n  const rows = Array(length)\r\n                .fill(true)\r\n                .map((v, i) => Array(length)\r\n                                .fill(i*length)\r\n                                .map((v, i) => v+i)\r\n                );\r\n\r\n  const columns = Array(length)\r\n                    .fill(true)\r\n                    .map((v, i) => Array(length)\r\n                                    .fill(i)\r\n                                    .map((v, i) => v + i*length)\r\n                    );\r\n\r\nconst diagonals = Array(2)\r\n                    .fill(true)\r\n                    .map((v,i) => Array(length)\r\n                                    .fill(i)\r\n                                    .map((v, i) => i*(length+1-v) + v*(length-i-v))\r\n                    );\r\n\r\n  // All the potential winning lines.\r\n  return [].concat(rows, columns, diagonals);\r\n}\r\n\r\nfunction calculateWinner(squares, length) {\r\n\r\n  let result = {\r\n    winner: null,\r\n    winningLine: null\r\n  };\r\n\r\n  // Get all the potential winning lines.\r\n  const lines = generateWinningLines(length);\r\n\r\n  const winningLines = lines\r\n    // For each potential winning line get the current played characters from the game.\r\n    .map(indices => indices.map(index => ({index:index, value:squares[index]})))\r\n    // Remove lines which are not full.\r\n    .filter((line) => line.every((v) => v.value!==null))\r\n    // Remove lines where not all the characters are the same.\r\n    // Any lines remaining are winning lines.\r\n    .filter((line) => line.every((v,i,a) => a[0].value===v.value));\r\n\r\n  // If there are no winning lines return null.\r\n  if (winningLines.length < 1) return result;\r\n\r\n  // If there is at least one winning line then there should only be one.\r\n  const winningLine = winningLines[0];\r\n  // The winning character is the same across the line.\r\n  const winner = winningLine[0].value;\r\n  // Grab the winning squares index values\r\n  const winningLineIndices = winningLines[0].map((lines) => lines.index);\r\n\r\n  result.winner = winner;\r\n  result.winningLine = winningLineIndices;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Takes a linear index for a game square and returns the x,y coordinates\r\n * of the square, 0 indexed, counting left to right, top to bottom.\r\n * @param  {Number} index linear index of the square\r\n * @param  {Number} characteristicLength the board height, width and win line length\r\n * @return {Array}       x,y coordinates of the square\r\n */\r\nfunction indexToCoords(index, characteristicLength) {\r\n  const x = index % characteristicLength;\r\n  const y = Math.trunc(index/characteristicLength);\r\n\r\n  return [x,y];\r\n}\r\n\r\n/**\r\n * Get the indices of empty squares on the board.\r\n *\r\n * If a square is empty (value==null) then grab its index otherwise return null.\r\n * Then throw away the \"null\" indices, leaving a list of indices of empty squares.\r\n * @param  {Array} squares The game board.\r\n * @return {Array}         The list of indices of empty squares.\r\n */\r\nfunction getEmptySquareIndices(squares) {\r\n  return squares\r\n          .map((v,i) => v===null ? i : null)\r\n          .filter((v) => v!==null);\r\n}\r\n\r\n/**\r\n * Create an array n items long and fill it with the result of invoking function f.\r\n * For use with jsx markup descriptions.\r\n * @param  {Number} n length of array\r\n * @param  {Function} f function to generate array content.\r\n * @return {Array}   array of length n filled with results of calling f.\r\n */\r\nfunction repeat(n, f) {\r\n return Array(n).fill(true).map(() => f());\r\n}\r\n\r\n/**\r\n * Return a random array index between 0 and length-1\r\n * @param  {Number} length Length of the array to produce an index for.\r\n * @return {Number}     Random integer index between 0 and length-1.\r\n */\r\nfunction randIndex(length) {\r\n  return Math.floor(Math.random()*Math.floor(length));\r\n}\r\n\r\nexport {getPlayer, generateWinningLines, calculateWinner, indexToCoords, getEmptySquareIndices, repeat, randIndex};\r\n","/**\r\n * AI interfaces for tic-tac-toe\r\n */\r\nimport {getEmptySquareIndices, randIndex, generateWinningLines} from './game-functions.js';\r\nimport {\r\n  getInitialSquareWeights,\r\n  filterByAvailability,\r\n  winningLineToWeights,\r\n  lineWeightsToSquareWeights,\r\n  getBestMoves\r\n} from './ai-functions.js';\r\n\r\n\r\n\r\n/**************\r\n/** Random Choice\r\n***************/\r\n\r\n// 'Easy' option that picks a random empty square.\r\nfunction selectRandomEmptySquare(squares) {\r\n  const emptySquareIndices = getEmptySquareIndices(squares);\r\n  // Pick an empty square at random and return its\r\n  // index in the squares array representing the board.\r\n  return emptySquareIndices[randIndex(emptySquareIndices.length)];\r\n}\r\n\r\n\r\n/**************\r\n/** Better AI\r\n***************/\r\n\r\n/**\r\n * Algorithm to choose square most likely to constribute to a win\r\n *\r\n * 1. Generate a list of all potential winning lines.\r\n * 2. Eliminate those lines blocked by having at least one opponent\r\n *    character in them.\r\n * 3. For each remaining potential winning line:\r\n *  3.1. Give each square a value (weight) of 1.\r\n *  3.2. For each square occupied by your own character redistribute those\r\n *      values to the emtpy squares. This upweights squares in partially\r\n *      filled lines, favouring squares choices closer to winning states.\r\n * 4. For each square on the board give it a default weight of 0 then\r\n *    add the value of that square in each winning line. This is now a\r\n *    probabilitic map (if it were normalised) of moves that progress to a\r\n *    winning state. Note this takes no account of how close the opponent is to winning.\r\n * 5. Choose a square index randomly from the highest weighted squares.\r\n *\r\n * Extension\r\n * E1. Repeat the algorithm for the opponent character.\r\n * E2. If the highest opponent probability of winning is greater than your\r\n *      probability of winning then choose to block rather than move towards winning.\r\n */\r\n\r\n// Steps 1..5\r\nfunction selectBestSquareToWin(squares, opponentCharacter) {\r\n  // Set the initial square weights to zero.\r\n  const characteristicLength = Math.sqrt(squares.length);\r\n  const initialSquareWeights = getInitialSquareWeights(characteristicLength);\r\n\r\n  // 1.\r\n  const winningLines = generateWinningLines(characteristicLength);\r\n\r\n  // 2.\r\n  const remainingWinningLines = filterByAvailability(squares, winningLines, opponentCharacter);\r\n  // If there are no more winning moves return a random empty square.\r\n  if (remainingWinningLines.length === 0) {\r\n    return ({\r\n      squareIndex: selectRandomEmptySquare(squares),\r\n      weight: 0\r\n    });\r\n  }\r\n\r\n  // 3.\r\n  const winningLineWeights = remainingWinningLines.map((line) => {\r\n    return winningLineToWeights(squares, line, characteristicLength);\r\n  });\r\n\r\n  // 4 For each square on the board sum the weights from the winning lines.\r\n  const squareWeights = lineWeightsToSquareWeights(winningLineWeights, initialSquareWeights);\r\n\r\n  // 5.\r\n  const bestMoves = getBestMoves(squareWeights);\r\n\r\n  // Return a random selection from the possible best moves.\r\n  return bestMoves[randIndex(bestMoves.length)];\r\n}\r\n\r\n// Steps E1..E2\r\nfunction getBestSquare(squares, myCharacter, opponentCharacter) {\r\n  const myBestSquare = selectBestSquareToWin(squares, opponentCharacter);\r\n  const opponentBestSquare = selectBestSquareToWin(squares, myCharacter);\r\n\r\n  // If we have the best move take it, otherwise block the opponents best move.\r\n  if (myBestSquare.weight >= opponentBestSquare.weight) {\r\n    return myBestSquare.squareIndex;\r\n  }\r\n  return opponentBestSquare.squareIndex;\r\n}\r\n\r\n// Just attack, don't care about defending.\r\nfunction getBestAttack(squares, opponentCharacter) {\r\n  return selectBestSquareToWin(squares, opponentCharacter).squareIndex;\r\n}\r\n\r\n/**************\r\n/** Export\r\n***************/\r\n\r\n/**\r\n * Pick a square on the board for the computer go and\r\n * return its index in the squares array.\r\n * @param  {Array} squares          The array representing the game baord.\r\n * @param  {String} myCharacter      Player Two (computer) character.\r\n * @param  {String} oponentCharacter Player One (human) character.\r\n * @return {Number}                  The index in `squares` representing the computer move choice.\r\n */\r\nfunction wopr(difficulty, squares, myCharacter, opponentCharacter) {\r\n  let squareIndex;\r\n  if (difficulty === \"easy\") {\r\n    squareIndex = selectRandomEmptySquare(squares);\r\n  } else if (difficulty === \"medium\") {\r\n    squareIndex = getBestAttack(squares, opponentCharacter);\r\n  } else {\r\n    squareIndex = getBestSquare(squares, myCharacter, opponentCharacter);\r\n  }\r\n  return squareIndex;\r\n}\r\n\r\nexport {wopr};\r\n","/**************\r\n/** AI Support Functions\r\n***************/\r\n\r\n// Return potential winning lines which aren't blocked by an opponent character.\r\nfunction filterByAvailability(squares, winningLines, oponentCharacter) {\r\n  return winningLines.filter((line) => {\r\n    const playedLine = line.map((index) => squares[index]);\r\n    return !playedLine.some((playedCaracter) => playedCaracter===oponentCharacter);\r\n  });\r\n}\r\n\r\nfunction getInitialSquareWeights(characteristicLength) {\r\n  return Array(characteristicLength*characteristicLength)\r\n          .fill()\r\n          .map((v,i) => ({squareIndex: i, weight: 0}));\r\n}\r\n\r\n// Map from winning line indices to to objects containing the square index and the weighting for that square in the current line.\r\n// Give each square in a potential winning line a weight of 1, then redistribute the weight between the empty squares in the line.\r\n// We don't care if non-empty character are ours or oponents because we already filtered out potential winning lines blocked by the opponent.\r\nfunction winningLineToWeights(squares, line, characteristicLength) {\r\n  const numEmptySquares = line.filter(squareIndex => squares[squareIndex]===null).length;\r\n  let totalLineWeight = characteristicLength;\r\n\r\n  // If the next move on this line wins the game upweight the line.\r\n  if (numEmptySquares === 1) totalLineWeight += 1;\r\n\r\n  return line.map(squareIndex => {\r\n    const isEmpty = squares[squareIndex]===null;\r\n    return {\r\n      squareIndex: squareIndex,\r\n      weight: isEmpty ? totalLineWeight / numEmptySquares : 0\r\n    };\r\n  })\r\n}\r\n\r\n// Iterate over the line weights and sum weights on the board.\r\nfunction lineWeightsToSquareWeights(lineWeights, initialSquareWeights) {\r\n  return (lineWeights\r\n    .reduce((flatArray, line) => flatArray.concat(line), [])\r\n    .reduce((accumulatingSquareWeights, square) => {\r\n      accumulatingSquareWeights[square.squareIndex].weight += square.weight;\r\n      return accumulatingSquareWeights;\r\n    }, initialSquareWeights));\r\n}\r\n\r\n// Given a board full of weights, get the best moves.\r\nfunction getBestMoves(squareWeights) {\r\n  // Sort weights in place.\r\n  squareWeights.sort((a, b) => a.weight < b.weight)\r\n  // Get highest weight;\r\n  const highestWeight = squareWeights[0].weight;\r\n  // Get the best move options.\r\n  return squareWeights.filter(square => square.weight === highestWeight);\r\n}\r\n\r\nexport {\r\n  filterByAvailability,\r\n  getInitialSquareWeights,\r\n  winningLineToWeights,\r\n  lineWeightsToSquareWeights,\r\n  getBestMoves\r\n};\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport {getPlayer, calculateWinner, indexToCoords, repeat, randIndex} from './game-functions.js'\r\nimport {\r\n  characteristicLength,\r\n  initialDifficulty,\r\n  difficultyOptions,\r\n  startMessage as initialStartMessage\r\n} from './game-config.js';\r\nimport {wopr} from './ai.js';\r\n\r\nimport './index.css';\r\n\r\nimport packageJson from '../package.json';\r\n\r\nimport anworldAudio from './audio/another-world-intro.mp3';\r\nimport rtypeAudio from './audio/r-type-title.mp3';\r\nimport shadowAudio from './audio/shadow-of-the-beast-intro.mp3';\r\n\r\n// The game board squares.\r\nfunction Square(props) {\r\n  const classNames = `square ${props.shouldHighlight ? 'highlight' : ''} ${props.isOnWinningLine ? 'winner':''}`;\r\n  return (\r\n    <button className={classNames} onClick={props.onClick} onMouseOver={props.onMouseOver} onMouseOut={props.onMouseOut}>\r\n      <span role=\"img\" aria-label=\"player character\">{props.playerCharacter}</span>\r\n    </button>\r\n  );\r\n}\r\n\r\n// The game board.\r\nclass Board extends React.Component {\r\n  renderSquare(i) {\r\n    const winningLine = this.props.winningLine;\r\n    const isOnWinningLine = winningLine!==null && winningLine.includes(i);\r\n    const shouldHighlight = this.props.highlight === i;\r\n\r\n    return (\r\n      <Square\r\n        key={'square'+i}\r\n        playerCharacter={this.props.squares[i]}\r\n        isOnWinningLine={isOnWinningLine}\r\n        shouldHighlight={shouldHighlight}\r\n        onMouseOver = {() => this.props.onMouseOver(i)}\r\n        onMouseOut = {() => this.props.onMouseOut(i)}\r\n        onClick={() => this.props.onClick(i)}\r\n      />\r\n    )\r\n  }\r\n\r\n  render() {\r\n    let i = 0;\r\n    let rowCounter = 0;\r\n\r\n    // Within each row for each column render a square.\r\n    const renderRow = () => {\r\n      return (\r\n        <div className=\"board-row\" key={'row'+(rowCounter++)}>\r\n          {repeat(characteristicLength, () => this.renderSquare(i++))}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // For each row render a row\r\n    return (\r\n      <div>\r\n        {repeat(characteristicLength, renderRow)}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// The top level Game object that holds state and controls rendering.\r\nclass Game extends React.Component {\r\n  constructor(props) {\r\n      super(props);\r\n\r\n      const music = [anworldAudio, rtypeAudio, shadowAudio];\r\n      const currentMusicIndex = randIndex(music.length);\r\n      const currentMusic = music[currentMusicIndex];\r\n\r\n      const numSquares = characteristicLength * characteristicLength;\r\n\r\n      this.state = {\r\n        history: [{\r\n          squares: Array(numSquares).fill(null),\r\n          indexPlayed: null,\r\n          move: 'No moves'\r\n        }],\r\n        startMessage: [],\r\n        stepNumber: 0,\r\n        playerOneNext: true,\r\n        isDraw: false,\r\n        winner: null,\r\n        winningLine: null,\r\n        music: music,\r\n        currentMusicIndex: currentMusicIndex,\r\n        currentMusic: currentMusic,\r\n        difficulty: initialDifficulty,\r\n        difficultyOptions: difficultyOptions,\r\n        gameLock: false,\r\n      }\r\n  }\r\n\r\n  haveAGo(i) {\r\n    const history = this.state.history.slice(0, this.state.stepNumber+1);\r\n    const current  = history[history.length - 1];\r\n    const squares = current.squares.slice();\r\n\r\n    const currentPlayer = getPlayer(this.state.playerOneNext);\r\n    squares[i] = currentPlayer;\r\n\r\n    const [xCoord, yCoord] = indexToCoords(i, characteristicLength);\r\n\r\n    const winningState = calculateWinner(squares, characteristicLength);\r\n    const winner = winningState.winner;\r\n    const winningLine = winningState.winningLine;\r\n\r\n    // If there is no winner and there are no empty squares it is a draw.\r\n    const isDraw = (winner===null) && !squares.includes(null);\r\n\r\n    this.setState({\r\n      history: history.concat([{\r\n        squares: squares,\r\n        indexPlayed: i,\r\n        move: currentPlayer + ' at (x:' + xCoord + ', y:' + yCoord + ')',\r\n      }]),\r\n      stepNumber: history.length,\r\n      playerOneNext: !this.state.playerOneNext,\r\n      isDraw: isDraw,\r\n      winner: winner,\r\n      winningLine: winningLine,\r\n      highlight: null,\r\n      reverseHistory: false\r\n    });\r\n  }\r\n\r\n  // Record which elements are being hovered over in the game state.\r\n  handleMouseOver(i) {\r\n    this.setState({highlight: i});\r\n  }\r\n  handleMouseOut(i) {\r\n    this.setState({highlight: null});\r\n  }\r\n\r\n  // This function advances the game logic.\r\n  handleBoardClick(i) {\r\n    const history = this.state.history.slice(0, this.state.stepNumber+1);\r\n    const current  = history[history.length - 1];\r\n    const squares = current.squares.slice();\r\n\r\n    // If there is a winner or draw or the square is not empty no action is needed.\r\n    if (this.state.winner || this.state.isDraw || squares[i]) return;\r\n\r\n\r\n    // The game board UI needs to be disabled until human and computer goes\r\n    // are finished otherwise a fast clicker can have the computer's go.\r\n    if (this.state.gameLock) return;\r\n    this.setState({gameLock: true});\r\n\r\n    // Have the human go. This updates game state.\r\n    this.haveAGo(i);\r\n\r\n    // If the second player is human don't invoke AI.\r\n    if(this.state.difficulty === 'human') {\r\n        this.setState({gameLock: false});\r\n        return;\r\n    }\r\n\r\n    // Have the computer go.\r\n    // setState can be asynch. Can pass callbacks to setState.\r\n    // Need to research React specific patterns for handling the next\r\n    // action (state change) being dependent on the previous state.\r\n    // For now force a render cycle to complete state update.\r\n    // https://reactjs.org/docs/react-component.html#forceUpdate\r\n    this.forceUpdate(() => {\r\n      const history = this.state.history.slice(0, this.state.stepNumber+1);\r\n      const current  = history[history.length - 1];\r\n      const squares = current.squares.slice();\r\n      const computerCharacter = getPlayer(this.state.playerOneNext);\r\n      const humanCharacter = getPlayer(!this.state.playerOneNext);\r\n      const difficulty = this.state.difficulty;\r\n\r\n      // If the game ended with the last click then no further action is needed.\r\n      if (this.state.winner || this.state.isDraw) return;\r\n\r\n      const computerSquareChoice = wopr(difficulty, squares, computerCharacter, humanCharacter);\r\n\r\n      // Make it seem like the computer is thinking...\r\n      const delay = 300 + Math.floor(Math.random()*500);\r\n      setTimeout(() => {\r\n        this.haveAGo(computerSquareChoice);\r\n\r\n        // Re-enable the board UI.\r\n        this.setState({gameLock: false});\r\n      }, delay);\r\n    });\r\n  }\r\n\r\n  jumpTo(step) {\r\n    /* TODO: Move all changeable state except stepNumber into the history array,\r\n    then we only need to set `stepNumber` here */\r\n    this.setState({\r\n      stepNumber: step,\r\n      playerOneNext: (step % 2) === 0,\r\n      winner: null,\r\n      isDraw: false,\r\n      winningLine: null,\r\n      gameLock: false,\r\n    });\r\n  }\r\n\r\n  reverseHistory() {\r\n    this.setState({\r\n      reverseHistory: !this.state.reverseHistory\r\n    });\r\n  }\r\n\r\n  handleEnded() {\r\n    const music = this.state.music;\r\n    let currentMusicIndex = this.state.currentMusicIndex;\r\n    currentMusicIndex = (currentMusicIndex + 1) % music.length;\r\n\r\n    let currentMusic = music[currentMusicIndex];\r\n\r\n    this.setState({\r\n      currentMusicIndex: currentMusicIndex,\r\n      currentMusic: currentMusic\r\n    });\r\n  }\r\n\r\n  handleDifficultyChange(e) {\r\n    const newDifficulty = e.target.value;\r\n    this.setState({\r\n      difficulty: newDifficulty\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const history = this.state.history;\r\n    const stepNumber = this.state.stepNumber;\r\n    const current = history[this.state.stepNumber];\r\n    const winner = this.state.winner;\r\n    const isDraw = this.state.isDraw;\r\n    const winningLine = this.state.winningLine;\r\n    const highlight = this.state.highlight;\r\n    const reverseHistory = this.state.reverseHistory;\r\n    const startMessage = this.state.startMessage.slice();\r\n    const difficulty = this.state.difficulty;\r\n    const difficultyOptions = this.state.difficultyOptions.slice();\r\n\r\n    const moveListItems = history.map((step, moveNumber) => {\r\n      const gameStart = <><span role=\"img\" aria-label=\"restart game\">ðŸ”ƒ</span><span> Go to game start</span></>\r\n      const desc = moveNumber > 0 ? 'Go to move #' + moveNumber + '. ' + step.move : gameStart;\r\n      const isCurrent = moveNumber===stepNumber;\r\n      const shouldHighlight = highlight!==null && highlight===step.indexPlayed;\r\n      const currentClass = `${isCurrent ? 'current' : ''}`;\r\n      const highlightClass = `${shouldHighlight ? 'highlight' : ''}`;\r\n      return (\r\n        <li key={moveNumber} className={currentClass}>\r\n          <button\r\n            className={highlightClass}\r\n            onClick={() => this.jumpTo(moveNumber)}\r\n            onMouseOver={() => this.handleMouseOver(step.indexPlayed)}\r\n            onMouseOut={() => this.handleMouseOut(step.indexPlayed)}\r\n            >{desc}</button>\r\n        </li>\r\n      );\r\n    });\r\n\r\n    const difficultyOptionEls = difficultyOptions.map((option) => {\r\n      return (\r\n        <option key={option} value={option}>{option}</option>\r\n      );\r\n    });\r\n\r\n    let status;\r\n    // At game start, loop over the contents of the start message by repeatedly\r\n    // setting state in a timeout causing render to be called.\r\n    // Creates typing effect.\r\n    if (this.state.stepNumber===0) {\r\n      // Set message with blinking cursor every other iteration.\r\n      // On occasion race conditions make this hilariously buggy.\r\n      status = startMessage.concat(initialStartMessage.length%2===1 ? '_' : '');\r\n      if(initialStartMessage.length) {\r\n        let letter = initialStartMessage.shift();\r\n        setTimeout(() => {\r\n          let currentMessage = startMessage.concat(letter);\r\n          // This causes the rerender and so loop.\r\n          this.setState({\r\n            startMessage: currentMessage\r\n          })\r\n        }, 130);\r\n      }\r\n    } else if (isDraw) {\r\n      status = <span>It's a tie. How about a nice <a href=\"https://www.chess.com/play/computer\">game of chess?</a></span>;\r\n    } else if (winner) {\r\n      status = 'Winner: ' + this.state.winner;\r\n    } else {\r\n      status = 'Next player: ' + getPlayer(this.state.playerOneNext);\r\n    }\r\n\r\n    return (\r\n      <div className=\"background\">\r\n        <div className=\"game\">\r\n          <div className=\"game-board\">\r\n            <Board\r\n              squares={current.squares}\r\n              winningLine = {winningLine}\r\n              highlight = {highlight}\r\n              onClick={(i) => this.handleBoardClick(i)}\r\n              onMouseOver={(i) => this.handleMouseOver(i)}\r\n              onMouseOut={(i) => this.handleMouseOut(i)}\r\n            />\r\n          </div>\r\n          <section className=\"controls\">\r\n            <div className=\"game-info\">\r\n              <div className={`status ${winner?'winner':''}`}>{status}</div>\r\n              <button className=\"reverse-history\" onClick={() => this.reverseHistory()}>Reverse order</button>\r\n              <ol className=\"history\">{reverseHistory ? moveListItems.reverse() : moveListItems}</ol>\r\n            </div>\r\n            <figure className=\"options\">\r\n              <figcaption>Music from <a href=\"https://retro.sx\">retro.sx</a></figcaption>\r\n              <audio controls src={this.state.currentMusic} preload=\"none\" autoPlay={true} onEnded={() => this.handleEnded()}>\r\n                <p>Your browser does not support the <code>audio</code> element.</p>\r\n              </audio>\r\n              <div className=\"difficulty\">\r\n                <label>Opponent: <select value={difficulty} onChange={(e) => this.handleDifficultyChange(e)}>{difficultyOptionEls}</select></label>\r\n              </div>\r\n              <div className=\"source-link\"><a href=\"https://github.com/jimCresswell/triple-t\">Source code available here.</a></div>\r\n            </figure>\r\n          </section>\r\n        </div>\r\n        <div className=\"version\">v{packageJson.version}</div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(\r\n  <Game />,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}